#version: "3.9"

services:
  web:
    # Пока в dev будем строить образ прямо из текущей папки.
    # В проде здесь будет image: ghcr.io/... (поменяем позже).
    build: .
    container_name: testci

    # Подключаем .env, чтобы внутрь контейнера попали переменные окружения.
    env_file:
      - .env

    # Можно продублировать/переопределить конкретные переменные так:
    environment:
      FLASK_ENV: ${APP_ENV:-production}

    # Пробрасываем наружу порт: Хост:Контейнер
    ports:
      - "${APP_PORT:-8000}:8000"

    # Полезно для "долгоживущего" сервиса: Docker будет его рестартить при падении.
    restart: unless-stopped

    # (чуть наперёд) healthcheck — нужен будет Watchtower и monitoring:
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://127.0.0.1:8000/health || exit 1"]
      interval: 30s
      timeout: 3s
      retries: 3
    
    labels:
      # метка нам потом пригодится, когда будем подключать watchtower
      com.centurylinklabs.watchtower.enable: "true"

  bot:
    build: .
    container_name: cd-demo-bot
    # Тот же образ, что и web (у нас один Dockerfile),
    # но CMD будет другим (override).
    command: ["python", "bot.py"]

    env_file:
      - .env
    environment:
      WEB_HOST: "web"
      WEB_PORT: "8000"
      BOT_INTERVAL: "5"
      APP_ENV: ${APP_ENV:-production}

    depends_on:
      - web
    restart: unless-stopped
    labels:
      com.centurylinklabs.watchtower.enable: "true"